<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>tools.analyzer.jvm AST Quickref</title>
  <style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  body {
    font-family: "Lucida Grande", "Trebuchet MS", "Bitstream Vera Sans", Verdana, Helvetica, sans-serif;
    font-size: 13px;
    line-height: 20px;
    margin: 40px 80px;
  }
  main {
    margin-left: 240px;
    width: 680px;
  }
  dl {
  display: flex;
  flex-flow: row wrap;

  }
  dt:nth-of-type(odd), dd:nth-of-type(odd) {
    background: #f5f5f5;
  }
  dt {
    padding: 2px 0; width: 120px;
    color:#191970;
  }
  dd { padding: 2px 0; width: 560px;}
  .wide-keys dt { width: 160px; }
  .wide-keys dd { width: 520px; }
  code, dt { font-family: "Menlo"; }
  code { color: rgb(160,40,160); }
  .page-title {
    font-size: 32px;
    border-bottom: none;
    margin-bottom: 2.75rem;
  }
  h1 {
    border-bottom: 1px solid #ccc;
    padding-bottom: 0.75em;
    margin-bottom: 1.5rem;
  }
  h2 {
    margin-bottom: 0.2rem;
    position: relative;
    padding-left: 20px;
    margin-left: -20px;
  }
  h4 {
    margin-bottom: 1rem;
  }

  h2 a {
    color: #aaa;
    font-size: 16px;
    font-weight: normal;
    margin-left: -20px;
    position: absolute;
    text-decoration: none;
    vertical-align: middle;
    visibility: hidden;
  }
  h2:hover a {
    visibility: visible;
  }
  p {
    margin-bottom: 1rem;
  }
  section {
    /*border-bottom: 1px solid #ccc;*/
    margin-bottom: 1rem;
    padding-bottom: 1rem;
  }
  nav {
    background: #f5f5f5;
    font-size: 11px;
    line-height: 14px;
    padding: 0.5rem 1rem;
    position: fixed;
    width: 160px;
  }
  nav ul {
    list-style: none;
    margin-bottom: 1rem;
  }
  nav ul:last-child { margin-bottom: 0; }
  </style>
</head>
<body>
  <nav>
    <strong>Nodes reference</strong>
    <ul>
      <li><a href="#binding">binding</a></li>
<li><a href="#case">case</a></li>
<li><a href="#case-test">case-test</a></li>
<li><a href="#case-then">case-then</a></li>
<li><a href="#catch">catch</a></li>
<li><a href="#const">const</a></li>
<li><a href="#def">def</a></li>
<li><a href="#deftype">deftype</a></li>
<li><a href="#do">do</a></li>
<li><a href="#fn">fn</a></li>
<li><a href="#fn-method">fn-method</a></li>
<li><a href="#host-interop">host-interop</a></li>
<li><a href="#if">if</a></li>
<li><a href="#import">import</a></li>
<li><a href="#instance-call">instance-call</a></li>
<li><a href="#instance-field">instance-field</a></li>
<li><a href="#instance?">instance?</a></li>
<li><a href="#invoke">invoke</a></li>
<li><a href="#keyword-invoke">keyword-invoke</a></li>
<li><a href="#let">let</a></li>
<li><a href="#letfn">letfn</a></li>
<li><a href="#local">local</a></li>
<li><a href="#loop">loop</a></li>
<li><a href="#map">map</a></li>
<li><a href="#method">method</a></li>
<li><a href="#monitor-enter">monitor-enter</a></li>
<li><a href="#monitor-exit">monitor-exit</a></li>
<li><a href="#new">new</a></li>
<li><a href="#primitive-invoke">primitive-invoke</a></li>
<li><a href="#protocol-invoke">protocol-invoke</a></li>
<li><a href="#quote">quote</a></li>
<li><a href="#recur">recur</a></li>
<li><a href="#reify">reify</a></li>
<li><a href="#set">set</a></li>
<li><a href="#set!">set!</a></li>
<li><a href="#static-call">static-call</a></li>
<li><a href="#static-field">static-field</a></li>
<li><a href="#the-var">the-var</a></li>
<li><a href="#throw">throw</a></li>
<li><a href="#try">try</a></li>
<li><a href="#var">var</a></li>
<li><a href="#vector">vector</a></li>
<li><a href="#with-meta">with-meta</a></li>

    </ul>
  </nav>
  <main>
    <h1 class="page-title">tools.analyzer.jvm AST Quickref</h1>
    <h1>Common AST fields</h1>
    <section><dl><dt>:op</dt><dd>The node op</dd><dt>:form</dt><dd>The clojure form from which the node originated</dd><dt>:env</dt><dd>The environment map</dd><dt>:children</dt><dd><b>optional</b> A vector of keywords, representing the children nodes of this node, in order of evaluation</dd><dt>:raw-forms</dt><dd><b>optional</b> If this node's <code>:form</code> has been macroexpanded, a sequence of all the intermediate forms from the original form to the macroexpanded form</dd><dt>:top-level</dt><dd><b>optional</b> <code>true</code> if this is the root node</dd><dt>:tag</dt><dd>The tag this expression is required to have</dd><dt>:o-tag</dt><dd>The tag of this expression, based on the node's children</dd><dt>:ignore-tag</dt><dd><b>optional</b> <code>true</code> if this node returns a statement rather than an expression</dd><dt>:loops</dt><dd><b>optional</b> A set of the loop-ids that might cause this node to recur</dd></dl></section>

    <h1>Nodes reference</h1>
    <section><h2><a href="#binding" name="binding">#</a>binding</h2><h4>Node for a binding symbol</h4><dl><dt> :op </dt> <dd> <code>:binding</code></dd><dt>:form</dt><dd>The binding symbol</dd><dt>:name</dt><dd>The uniquified binding symbol</dd><dt>:local</dt><dd>One of <code>:arg</code>, <code>:catch</code>, <code>:fn</code>, <code>:let</code>, <code>:letfn</code>, <code>:loop</code>, <code>:field</code> or <code>:this</code></dd><dt>:arg-id</dt><dd><b>optional</b> When <code>:local</code> is <code>:arg</code>, the parameter index</dd><dt>:variadic?</dt><dd><b>optional</b> When <code>:local</code> is <code>:arg</code>, a boolean indicating whether this parameter binds to a variable number of arguments</dd><dt>:init</dt><dd><b>optional</b> When <code>:local</code> is <code>:let</code>, <code>:letfn</code> or <code>:loop</code>, an AST node representing the bound value</dd><dt>:atom</dt><dd>An atom shared by this <code>:binding</code> node and all the <code>:local</code> nodes that refer to this binding</dd><dt> :children </dt> <dd> <code>[]</code>, <code>[:init]</code></dd></dl></section>
<section><h2><a href="#case" name="case">#</a>case</h2><h4>Node for a case* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:case</code></dd><dt>:form</dt><dd><code>(case* expr shift maks default case-map switch-type test-type skip-check?)</code></dd><dt>:test</dt><dd>The AST node for the expression to test against</dd><dt>:tests</dt><dd>A vector of <code>:case-test</code> AST nodes, each node has a corresponding <code>:case-then</code> node in the <code>:thens</code> field</dd><dt>:thens</dt><dd>A vector of <code>:case-then</code> AST nodes, each node has a corresponding <code>:case-test</code> node in the <code>:tests</code> field</dd><dt>:default</dt><dd>An AST node representing the default value of the case expression</dd><dt>:shift</dt><dd></dd><dt>:mask</dt><dd></dd><dt>:low</dt><dd></dd><dt>:high</dt><dd></dd><dt>:switch-type</dt><dd>One of <code>:sparse</code> or <code>:compact</code></dd><dt>:test-type</dt><dd>One of <code>:int</code>, <code>:hash-equiv</code> or <code>:hash-identity</code></dd><dt>:skip-check?</dt><dd>A set of case ints for which equivalence checking should not be done</dd><dt> :children </dt> <dd> <code>[:test :tests :thens :default]</code></dd></dl></section>
<section><h2><a href="#case-test" name="case-test">#</a>case-test</h2><h4>Node for a test value in a case* expression</h4><dl><dt> :op </dt> <dd> <code>:case-test</code></dd><dt>:test</dt><dd>A <code>:const</code> AST node representing the test value</dd><dt>:hash</dt><dd></dd><dt> :children </dt> <dd> <code>[:test]</code></dd></dl></section>
<section><h2><a href="#case-then" name="case-then">#</a>case-then</h2><h4>Node for a then expression in a case* expression</h4><dl><dt> :op </dt> <dd> <code>:case-then</code></dd><dt>:then</dt><dd>An AST node representing the expression the case will evaluate to when the <code>:test</code> expression matches this node's corresponding <code>:case-test</code> value</dd><dt>:hash</dt><dd></dd><dt> :children </dt> <dd> <code>[:then]</code></dd></dl></section>
<section><h2><a href="#catch" name="catch">#</a>catch</h2><h4>Node for a catch expression</h4><dl><dt> :op </dt> <dd> <code>:catch</code></dd><dt>:form</dt><dd><code>(catch class local body*)</code></dd><dt>:class</dt><dd>A <code>:const</code> AST node with <code>:type</code> <code>:class</code> representing the type of exception to catch</dd><dt>:local</dt><dd>The <code>:binding</code> AST node for the caught exception</dd><dt>:body</dt><dd>Synthetic <code>:do</code> AST node (with <code>:body?</code> <code>true</code>)  representing the body of the catch clause</dd><dt> :children </dt> <dd> <code>[:class :local :body]</code></dd></dl></section>
<section><h2><a href="#const" name="const">#</a>const</h2><h4>Node for a constant literal or a quoted collection literal</h4><dl><dt> :op </dt> <dd> <code>:const</code></dd><dt>:form</dt><dd>A constant literal or a quoted collection literal</dd><dt>:literal?</dt><dd><code>true</code></dd><dt>:type</dt><dd>one of <code>:nil</code>, <code>:bool</code>, <code>:keyword</code>, <code>:symbol</code>, <code>:string</code>, <code>:number</code>, <code>:type</code>, <code>:record</code>, <code>:map</code>, <code>:vector</code>, <code>:set</code>, <code>:seq</code>, <code>:char</code>, <code>:regex</code>, <code>:class</code>, <code>:var</code>, or <code>:unknown</code></dd><dt>:val</dt><dd>The value of the constant node</dd><dt>:meta</dt><dd><b>optional</b> An AST node representing the metadata of the constant value, if present. The node will be either a <code>:map</code> node or a <code>:const</code> node with <code>:type</code> <code>:map</code></dd><dt> :children </dt> <dd> <code>[]</code>, <code>[:meta]</code></dd></dl></section>
<section><h2><a href="#def" name="def">#</a>def</h2><h4>Node for a def special-form expression</h4><dl><dt> :op </dt> <dd> <code>:def</code></dd><dt>:form</dt><dd><code>(def name docstring? init?)</code></dd><dt>:name</dt><dd>The var symbol to define in the current namespace</dd><dt>:var</dt><dd>The Var object created (or found, if it already existed) named by the symbol <code>:name</code> in the current namespace</dd><dt>:meta</dt><dd><b>optional</b> An AST node representing the metadata attached to <code>:name</code>, if present. The node will be either a <code>:map</code> node or a <code>:const</code> node with <code>:type</code> <code>:map</code></dd><dt>:init</dt><dd><b>optional</b> An AST node representing the initial value of the var</dd><dt>:doc</dt><dd><b>optional</b> The docstring for this var</dd><dt> :children </dt> <dd> <code>[]</code>, <code>[:init]</code>, <code>[:meta]</code>, <code>[:meta :init]</code></dd></dl></section>
<section><h2><a href="#deftype" name="deftype">#</a>deftype</h2><h4>Node for a deftype* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:deftype</code></dd><dt>:form</dt><dd><code>(deftype* name class.name [arg*] <code>:implements</code> [interface*] method*)</code></dd><dt>:interfaces</dt><dd>A set of the interfaces implemented by the type</dd><dt>:name</dt><dd>The symbol name of the deftype</dd><dt>:class-name</dt><dd>A class for the deftype, should *never* be instantiated or used on instance? checks as this will not be the same class the deftype will evaluate to after compilation</dd><dt>:fields</dt><dd>A vector of <code>:binding</code> AST nodes with <code>:local</code> <code>:field</code> representing the deftype fields</dd><dt>:methods</dt><dd>A vector <code>:method</code> AST nodes representing the deftype methods</dd><dt> :children </dt> <dd> <code>[:fields :methods]</code></dd></dl></section>
<section><h2><a href="#do" name="do">#</a>do</h2><h4>Node for a do special-form expression or for another special-form's body</h4><dl><dt> :op </dt> <dd> <code>:do</code></dd><dt>:form</dt><dd><code>(do statement* ret)</code></dd><dt>:statements</dt><dd>A vector of AST nodes representing all but the last expression in the do body</dd><dt>:ret</dt><dd>An AST node representing the last expression in the do body (the block's return value)</dd><dt>:body?</dt><dd><b>optional</b> <code>true</code> if this node is a synthetic body</dd><dt> :children </dt> <dd> <code>[:statements :ret]</code></dd></dl></section>
<section><h2><a href="#fn" name="fn">#</a>fn</h2><h4>Node for a fn* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:fn</code></dd><dt>:form</dt><dd><code>(fn* name? [arg*] body*)</code> or <code>(fn* name? method*)</code></dd><dt>:variadic?</dt><dd><code>true</code> if this function contains a variadic arity method</dd><dt>:max-fixed-arity</dt><dd>The number of arguments taken by the fixed-arity method taking the most arguments</dd><dt>:local</dt><dd><b>optional</b> A <code>:binding</code> AST node with <code>:local</code> <code>:fn</code> representing the function's local name, if one is supplied</dd><dt>:methods</dt><dd>A vector of <code>:fn-method</code> AST nodes representing the fn method arities</dd><dt>:once</dt><dd><code>true</code> if the fn is marked as <code>^<code>:once</code> fn*</code>, meaning it will only be executed once and thus allowing for the clearing of closed-over locals</dd><dt> :children </dt> <dd> <code>[:methods]</code>, <code>[:local :methods]</code></dd></dl></section>
<section><h2><a href="#fn-method" name="fn-method">#</a>fn-method</h2><h4>Node for an arity method in a fn* expression</h4><dl><dt> :op </dt> <dd> <code>:fn-method</code></dd><dt>:form</dt><dd><code>([arg*] body*)</code></dd><dt>:loop-id</dt><dd>Unique symbol identifying this method as a target for recursion</dd><dt>:variadic?</dt><dd><code>true</code> if this fn-method takes a variable number of arguments</dd><dt>:params</dt><dd>A vector of <code>:binding</code> AST nodes with <code>:local</code> <code>:arg</code> representing this fn-method args</dd><dt>:fixed-arity</dt><dd>The number of non-variadic args this fn-method takes</dd><dt>:body</dt><dd>Synthetic <code>:do</code> node (with <code>:body?</code> <code>true</code>) representing the body of this fn-method</dd><dt> :children </dt> <dd> <code>[:params :body]</code></dd></dl></section>
<section><h2><a href="#host-interop" name="host-interop">#</a>host-interop</h2><h4>Node for a no-arg instance-call or for an instance-field that couldn't be resolved at compile time</h4><dl><dt> :op </dt> <dd> <code>:host-interop</code></dd><dt>:form</dt><dd><code>(. target m-or-f)</code></dd><dt>:target</dt><dd>An AST node representing the target object</dd><dt>:m-or-f</dt><dd>Symbol naming the no-arg method or field to lookup in the target</dd><dt>:assignable?</dt><dd><code>true</code></dd><dt> :children </dt> <dd> <code>[:target]</code></dd></dl></section>
<section><h2><a href="#if" name="if">#</a>if</h2><h4>Node for an if special-form expression</h4><dl><dt> :op </dt> <dd> <code>:if</code></dd><dt>:form</dt><dd><code>(if test then else?)</code></dd><dt>:test</dt><dd>An AST node representing the test expression</dd><dt>:then</dt><dd>An AST node representing the expression's return value if <code>:test</code> evaluated to a truthy value</dd><dt>:else</dt><dd>An AST node representing the expression's return value if <code>:test</code> evaluated to a falsey value, if not supplied it will default to a <code>:const</code> node representing nil</dd><dt> :children </dt> <dd> <code>[:test :then :else]</code></dd></dl></section>
<section><h2><a href="#import" name="import">#</a>import</h2><h4>Node for a clojure.core/import* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:import</code></dd><dt>:form</dt><dd><code>(clojure.core/import* "qualified.class")</code></dd><dt>:class</dt><dd>String representing the qualified class to import</dd></dl></section>
<section><h2><a href="#instance-call" name="instance-call">#</a>instance-call</h2><h4>Node for an instance method call</h4><dl><dt> :op </dt> <dd> <code>:instance-call</code></dd><dt>:form</dt><dd><code>(.method instance arg*)</code></dd><dt>:method</dt><dd>Symbol naming the invoked method</dd><dt>:instance</dt><dd>An AST node representing the instance to call the method on</dd><dt>:args</dt><dd>A vector of AST nodes representing the args passed to the method call</dd><dt>:validated?</dt><dd><b>optional</b> <code>true</code> if the method call could be resolved at compile time</dd><dt>:class</dt><dd><b>optional</b> If <code>:validated?</code> the class or interface the method belongs to</dd><dt> :children </dt> <dd> <code>[:instance :args]</code></dd></dl></section>
<section><h2><a href="#instance-field" name="instance-field">#</a>instance-field</h2><h4>Node for an instance field access</h4><dl><dt> :op </dt> <dd> <code>:instance-field</code></dd><dt>:form</dt><dd><code>(.-field instance)</code></dd><dt>:field</dt><dd>Symbol naming the field to access</dd><dt>:instance</dt><dd>An AST node representing the instance to lookup the symbol on</dd><dt>:assignable?</dt><dd><code>true</code> if the field is set!able</dd><dt>:class</dt><dd>The class the field belongs to</dd><dt> :children </dt> <dd> <code>[:instance]</code></dd></dl></section>
<section><h2><a href="#instance?" name="instance?">#</a>instance?</h2><h4>Node for a clojure.core/instance? call where the Class is known at compile time</h4><dl><dt> :op </dt> <dd> <code>:instance?</code></dd><dt>:form</dt><dd><code>(clojure.core/instance? Class x)</code></dd><dt>:class</dt><dd>The Class to test the <code>:target</code> for instanceability</dd><dt>:target</dt><dd>An AST node representing the object to test for instanceability</dd><dt> :children </dt> <dd> <code>[:target]</code></dd></dl></section>
<section><h2><a href="#invoke" name="invoke">#</a>invoke</h2><h4>Node for an invoke expression</h4><dl><dt> :op </dt> <dd> <code>:invoke</code></dd><dt>:form</dt><dd><code>(f arg*)</code></dd><dt>:fn</dt><dd>An AST node representing the function to invoke</dd><dt>:args</dt><dd>A vector of AST nodes representing the args to the function</dd><dt>:meta</dt><dd><b>optional</b> Map of metadata attached to the invoke <code>:form</code></dd><dt> :children </dt> <dd> <code>[:fn :args]</code></dd></dl></section>
<section><h2><a href="#keyword-invoke" name="keyword-invoke">#</a>keyword-invoke</h2><h4>Node for an invoke expression where the fn is a not-namespaced keyword and thus a keyword callsite can be emitted</h4><dl><dt> :op </dt> <dd> <code>:keyword-invoke</code></dd><dt>:form</dt><dd><code>(<code>:k</code> instance)</code></dd><dt>:keyword</dt><dd>An AST node representing the keyword to lookup in the instance</dd><dt>:target</dt><dd>An AST node representing the instance to lookup the keyword in</dd><dt> :children </dt> <dd> <code>[:keyword :target]</code></dd></dl></section>
<section><h2><a href="#let" name="let">#</a>let</h2><h4>Node for a let* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:let</code></dd><dt>:form</dt><dd><code>(let* [binding*] body*)</code></dd><dt>:bindings</dt><dd>A vector of <code>:binding</code> AST nodes with <code>:local</code> <code>:let</code></dd><dt>:body</dt><dd>Synthetic <code>:do</code> node (with <code>:body?</code> <code>true</code>) representing the body of the let expression</dd><dt> :children </dt> <dd> <code>[:bindings :body]</code></dd></dl></section>
<section><h2><a href="#letfn" name="letfn">#</a>letfn</h2><h4>Node for a letfn* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:letfn</code></dd><dt>:form</dt><dd><code>(letfn* [binding*] body*)</code></dd><dt>:bindings</dt><dd>A vector of <code>:binding</code> AST nodes with <code>:local</code> <code>:letfn</code></dd><dt>:body</dt><dd>Synthetic <code>:do</code> node (with <code>:body?</code> <code>true</code>) representing the body of the letfn expression</dd><dt> :children </dt> <dd> <code>[:bindings :body]</code></dd></dl></section>
<section><h2><a href="#local" name="local">#</a>local</h2><h4>Node for a local symbol</h4><dl><dt> :op </dt> <dd> <code>:local</code></dd><dt>:form</dt><dd>The local symbol</dd><dt>:assignable?</dt><dd><code>true</code> if the corresponding <code>:binding</code> AST node is <code>:local</code> <code>:field</code> and is declared either ^<code>:volatile-mutable</code> or ^<code>:unsynchronized-mutable</code></dd><dt>:name</dt><dd>The uniquified local symbol</dd><dt>:local</dt><dd>One of <code>:arg</code>, <code>:catch</code>, <code>:fn</code>, <code>:let</code>, <code>:letfn</code>, <code>:loop</code>, <code>:field</code> or <code>:this</code></dd><dt>:arg-id</dt><dd><b>optional</b> When <code>:local</code> is <code>:arg</code>, the parameter index</dd><dt>:variadic?</dt><dd><b>optional</b> When <code>:local</code> is <code>:arg</code>, a boolean indicating whether this parameter binds to a variable number of arguments</dd><dt>:atom</dt><dd>An atom shared by this <code>:local</code> node, the <code>:binding</code> node this local refers to and all the other <code>:local</code> nodes that refer to this same local</dd></dl></section>
<section><h2><a href="#loop" name="loop">#</a>loop</h2><h4>Node a loop* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:loop</code></dd><dt>:form</dt><dd><code>(loop* [binding*] body*)</code></dd><dt>:bindings</dt><dd>A vector of <code>:binding</code> AST nodes with <code>:local</code> <code>:loop</code></dd><dt>:body</dt><dd>Synthetic <code>:do</code> node (with <code>:body?</code> <code>true</code>) representing the body of the loop expression</dd><dt>:loop-id</dt><dd>Unique symbol identifying this loop as a target for recursion</dd><dt> :children </dt> <dd> <code>[:bindings :body]</code></dd></dl></section>
<section><h2><a href="#map" name="map">#</a>map</h2><h4>Node for a map literal with attached metadata and/or non literal elements</h4><dl><dt> :op </dt> <dd> <code>:map</code></dd><dt>:form</dt><dd><code>{[key val]*}</code></dd><dt>:keys</dt><dd>A vector of AST nodes representing the keys of the map</dd><dt>:vals</dt><dd>A vector of AST nodes representing the vals of the map</dd><dt> :children </dt> <dd> <code>[:keys :vals]</code></dd></dl></section>
<section><h2><a href="#method" name="method">#</a>method</h2><h4>Node for a method in a deftype* or reify* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:method</code></dd><dt>:form</dt><dd><code>(method [this arg*] body*)</code></dd><dt>:bridges</dt><dd>A list of signature for bridge methods to emit</dd><dt>:interface</dt><dd>The interface (or Object) this method belongs to</dd><dt>:this</dt><dd>A <code>:binding</code> AST node with <code>:local</code> <code>:this</code> representing the "this" local</dd><dt>:loop-id</dt><dd>Unique symbol identifying this method as a target for recursion</dd><dt>:name</dt><dd>The symbol name of this method</dd><dt>:params</dt><dd>A vector of AST <code>:binding</code> nodes with <code>:local</code> <code>:arg</code> representing the arguments of the method</dd><dt>:fixed-arity</dt><dd>The number of args this method takes</dd><dt>:body</dt><dd>Synthetic <code>:do</code> node (with <code>:body?</code> <code>true</code>) representing the body of this method</dd><dt> :children </dt> <dd> <code>[:this :params :body]</code></dd></dl></section>
<section><h2><a href="#monitor-enter" name="monitor-enter">#</a>monitor-enter</h2><h4>Node for a monitor-enter special-form statement</h4><dl><dt> :op </dt> <dd> <code>:monitor-enter</code></dd><dt>:form</dt><dd><code>(monitor-enter target)</code></dd><dt>:target</dt><dd>An AST node representing the monitor-enter sentinel</dd><dt> :children </dt> <dd> <code>[:target]</code></dd></dl></section>
<section><h2><a href="#monitor-exit" name="monitor-exit">#</a>monitor-exit</h2><h4>Node for a monitor-exit special-form statement</h4><dl><dt> :op </dt> <dd> <code>:monitor-exit</code></dd><dt>:form</dt><dd><code>(monitor-exit target)</code></dd><dt>:target</dt><dd>An AST node representing the monitor-exit sentinel</dd><dt> :children </dt> <dd> <code>[:target]</code></dd></dl></section>
<section><h2><a href="#new" name="new">#</a>new</h2><h4>Node for a new special-form expression</h4><dl><dt> :op </dt> <dd> <code>:new</code></dd><dt>:form</dt><dd><code>(new Class arg*)</code></dd><dt>:class</dt><dd>A <code>:const</code> AST node with <code>:type</code> <code>:class</code> representing the Class to instantiate</dd><dt>:args</dt><dd>A vector of AST nodes representing the arguments passed to the Class constructor</dd><dt>:validated?</dt><dd><b>optional</b> <code>true</code> if the constructor call could be resolved at compile time</dd><dt> :children </dt> <dd> <code>[:class :args]</code></dd></dl></section>
<section><h2><a href="#primitive-invoke" name="primitive-invoke">#</a>primitive-invoke</h2><h4>Node for an invoke expression that can be optimized using one of the primitive interfaces in IFn</h4><dl><dt> :op </dt> <dd> <code>:primitive-invoke</code></dd><dt>:form</dt><dd><code>(prim-f arg*)</code></dd><dt>:fn</dt><dd>An AST node representing the function to invoke</dd><dt>:args</dt><dd>A vector of AST nodes representing the args to the function</dd><dt>:prim-interface</dt><dd>The primitive interface in IFn that will be used</dd><dt>:meta</dt><dd><b>optional</b> Map of metadata attached to the invoke <code>:form</code></dd><dt> :children </dt> <dd> <code>[:fn :args]</code></dd></dl></section>
<section><h2><a href="#protocol-invoke" name="protocol-invoke">#</a>protocol-invoke</h2><h4>Node for an invoke expression where the function is a protocol function var</h4><dl><dt> :op </dt> <dd> <code>:protocol-invoke</code></dd><dt>:form</dt><dd><code>(proto-fn target arg*)</code></dd><dt>:protocol-fn</dt><dd>An AST node representing the protocol function var to invoke</dd><dt>:target</dt><dd>An AST node representing the target of the protocol function call</dd><dt>:args</dt><dd>A vector of AST nodes representing the args to the protocol function</dd><dt> :children </dt> <dd> <code>[:protocol-fn :target :args]</code></dd></dl></section>
<section><h2><a href="#quote" name="quote">#</a>quote</h2><h4>Node for a quote special-form expression</h4><dl><dt> :op </dt> <dd> <code>:quote</code></dd><dt>:form</dt><dd><code>(quote expr)</code></dd><dt>:expr</dt><dd>A <code>:const</code> AST node representing the quoted value</dd><dt>:literal?</dt><dd><code>true</code></dd><dt> :children </dt> <dd> <code>[:expr]</code></dd></dl></section>
<section><h2><a href="#recur" name="recur">#</a>recur</h2><h4>Node for a recur special-form expression</h4><dl><dt> :op </dt> <dd> <code>:recur</code></dd><dt>:form</dt><dd><code>(recur expr*)</code></dd><dt>:exprs</dt><dd>A vector of AST nodes representing the new bound values for the loop binding on the next loop iteration</dd><dt>:loop-id</dt><dd>Unique symbol identifying the enclosing loop target</dd><dt> :children </dt> <dd> <code>[:exprs]</code></dd></dl></section>
<section><h2><a href="#reify" name="reify">#</a>reify</h2><h4>Node for a reify* special-form expression</h4><dl><dt> :op </dt> <dd> <code>:reify</code></dd><dt>:form</dt><dd><code>(reify* [interface*] method*)</code></dd><dt>:interfaces</dt><dd>A set of the interfaces implemented by the generated type</dd><dt>:class-name</dt><dd>The generated class for the reify, should *never* be instantiated or used on instance? checks</dd><dt>:methods</dt><dd>A vector <code>:method</code> AST nodes representing the reify methods</dd><dt> :children </dt> <dd> <code>[:methods]</code></dd></dl></section>
<section><h2><a href="#set" name="set">#</a>set</h2><h4>Node for a set literal with attached metadata and/or non literal elements</h4><dl><dt> :op </dt> <dd> <code>:set</code></dd><dt>:form</dt><dd><code>#{item*}</code></dd><dt>:items</dt><dd>A vector of AST nodes representing the items of the set</dd><dt> :children </dt> <dd> <code>[:items]</code></dd></dl></section>
<section><h2><a href="#set!" name="set!">#</a>set!</h2><h4>Node for a set! special-form expression</h4><dl><dt> :op </dt> <dd> <code>:set!</code></dd><dt>:form</dt><dd><code>(set! target val)</code></dd><dt>:target</dt><dd>An AST node representing the target of the set! expression, must be <code>:assignable?</code></dd><dt>:val</dt><dd>An AST node representing the new value for the target</dd><dt> :children </dt> <dd> <code>[:target :val]</code></dd></dl></section>
<section><h2><a href="#static-call" name="static-call">#</a>static-call</h2><h4>Node for a static method call</h4><dl><dt> :op </dt> <dd> <code>:static-call</code></dd><dt>:form</dt><dd><code>(Class/method arg*)</code></dd><dt>:class</dt><dd>The Class the static method belongs to</dd><dt>:method</dt><dd>The symbol name of the static method</dd><dt>:args</dt><dd>A vector of AST nodes representing the args to the method call</dd><dt>:validated?</dt><dd><b>optional</b> <code>true</code> if the static method could be resolved at compile time</dd><dt> :children </dt> <dd> <code>[:args]</code></dd></dl></section>
<section><h2><a href="#static-field" name="static-field">#</a>static-field</h2><h4>Node for a static field access</h4><dl><dt> :op </dt> <dd> <code>:static-field</code></dd><dt>:form</dt><dd><code>Class/field</code></dd><dt>:class</dt><dd>The Class the static field belongs to</dd><dt>:field</dt><dd>The symbol name of the static field</dd><dt>:assignable?</dt><dd><b>optional</b> <code>true</code> if the static field is set!able</dd></dl></section>
<section><h2><a href="#the-var" name="the-var">#</a>the-var</h2><h4>Node for a var special-form expression</h4><dl><dt> :op </dt> <dd> <code>:the-var</code></dd><dt>:form</dt><dd><code>(var var-name)</code></dd><dt>:var</dt><dd>The Var object this expression refers to</dd></dl></section>
<section><h2><a href="#throw" name="throw">#</a>throw</h2><h4>Node for a throw special-form statement</h4><dl><dt> :op </dt> <dd> <code>:throw</code></dd><dt>:form</dt><dd><code>(throw exception)</code></dd><dt>:exception</dt><dd>An AST node representing the exception to throw</dd><dt> :children </dt> <dd> <code>[:exception]</code></dd></dl></section>
<section><h2><a href="#try" name="try">#</a>try</h2><h4>Node for a try special-form expression</h4><dl><dt> :op </dt> <dd> <code>:try</code></dd><dt>:form</dt><dd><code>(try body* catch* finally?)</code></dd><dt>:body</dt><dd>Synthetic <code>:do</code> AST node (with <code>:body?</code> <code>true</code>) representing the body of this try expression</dd><dt>:catches</dt><dd>A vector of <code>:catch</code> AST nodes representing the catch clauses of this try expression</dd><dt>:finally</dt><dd><b>optional</b> Synthetic <code>:do</code> AST node (with <code>:body?</code> <code>true</code>) representing the final clause of this try expression</dd><dt> :children </dt> <dd> <code>[:body :catches]</code>, <code>[:body :catches :finally]</code></dd></dl></section>
<section><h2><a href="#var" name="var">#</a>var</h2><h4>Node for a var symbol</h4><dl><dt> :op </dt> <dd> <code>:var</code></dd><dt>:form</dt><dd>A symbol naming the var</dd><dt>:var</dt><dd>The Var object this symbol refers to</dd><dt>:assignable?</dt><dd><b>optional</b> <code>true</code> if the Var is <code>:dynamic</code></dd></dl></section>
<section><h2><a href="#vector" name="vector">#</a>vector</h2><h4>Node for a vector literal with attached metadata and/or non literal elements</h4><dl><dt> :op </dt> <dd> <code>:vector</code></dd><dt>:form</dt><dd><code>[item*]</code></dd><dt>:items</dt><dd>A vector of AST nodes representing the items of the vector</dd><dt> :children </dt> <dd> <code>[:items]</code></dd></dl></section>
<section><h2><a href="#with-meta" name="with-meta">#</a>with-meta</h2><h4>Node for a non quoted collection literal or fn/reify expression with attached metadata</h4><dl><dt> :op </dt> <dd> <code>:with-meta</code></dd><dt>:form</dt><dd>Non quoted collection literal or fn/reify expression with attached metadata</dd><dt>:meta</dt><dd>An AST node representing the metadata of expression. The node will be either a <code>:map</code> node or a <code>:const</code> node with <code>:type</code> <code>:map</code></dd><dt>:expr</dt><dd>The expression this metadata is attached to, <code>:op</code> is one of <code>:vector</code>, <code>:map</code>, <code>:set</code>, <code>:fn</code> or <code>:reify</code></dd><dt> :children </dt> <dd> <code>[:meta :expr]</code></dd></dl></section>

  </main>
</body>
</html>
